//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

func main() {
	if err := gen_pen(); err != nil {
		panic(err)
	}
}

func gen_pen() error {
	url := "https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers"
	outPath := "generated.pen.go"

	var bb bytes.Buffer

	fmt.Fprintf(&bb, "// Code generated by go generate; DO NOT EDIT.\n\n")
	fmt.Fprintf(&bb, "package pen\n\n")

	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("got HTTP status code %v for %v", resp.StatusCode, url)
	}
	if err := parserPEN(&bb, resp.Body); err != nil {
		return fmt.Errorf("parse for http resp body failed, err: %s", err)
	}
	fmt.Fprintf(&bb, "\n")

	b, err := format.Source(bb.Bytes())
	if err != nil {
		return fmt.Errorf("format code failed, err: %s", err)
	}

	if err := writeFile(outPath, b); err != nil {
		return fmt.Errorf("write file failed, err: %s", err)
	}

	return nil
}

func parserPEN(w io.Writer, r io.Reader) error {
	type (
		Enterprise struct {
			ID      uint32
			Org     string
			Contact string
			Email   string
		}
		Expect uint8
	)
	const (
		ExpectID Expect = iota
		ExpectOrg
		ExpectContact
		ExpectEmail
	)
	var (
		es     []Enterprise
		e      Enterprise
		expect Expect = ExpectID
	)

	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		line := scanner.Text()

		switch expect {
		case ExpectID:
			idPattern := regexp.MustCompile(`^[0-9]+\s*$`)
			if idPattern.Match([]byte(line)) {
				id, _ := strconv.Atoi(strings.TrimSpace(line))
				// Find a new Enterprise section
				e = Enterprise{}
				e.ID = uint32(id)
				expect = ExpectOrg
			}

		case ExpectOrg:
			orgPattern := regexp.MustCompile(`^  \w[\w ]*`)
			if orgPattern.Match([]byte(line)) {
				org := strings.TrimSpace(line)
				e.Org = cleanOrgString(org)
				expect = ExpectContact
			}

		case ExpectContact:
			contactPattern := regexp.MustCompile(`^    \w[\w ]*`)
			if contactPattern.Match([]byte(line)) {
				contact := strings.TrimSpace(line)
				contact = strings.ReplaceAll(contact, "\"", "")
				e.Contact = contact
			}
			expect = ExpectEmail

		case ExpectEmail:
			emailPattern := regexp.MustCompile(`^      \w[\w ]*`)
			if emailPattern.Match([]byte(line)) {
				e.Email = strings.TrimSpace(line)
				es = append(es, e)
				// Next
				expect = ExpectID
			}
		}
	}

	fmt.Fprintf(w, "// PENs holds all IANA registered Private Enterprise Numbers\n")
	fmt.Fprintf(w, "var PENs = map[uint32]string{\n")
	for _, e := range es {
		fmt.Fprintf(w, "%d: \"%s\",\n", e.ID, e.Org)
	}
	fmt.Fprintf(w, "}\n")
	return nil
}

func cleanOrgString(orgLong string) string {
	var s string
	s = strings.Split(orgLong, "(")[0]
	s = strings.Split(s, ",")[0]
	s = strings.TrimSpace(s)
	s = onlyKeepValidChars(s)
	return s
}

func onlyKeepValidChars(s string) string {
	var result strings.Builder
	for i := 0; i < len(s); i++ {
		b := s[i]
		if ('a' <= b && b <= 'z') ||
			('A' <= b && b <= 'Z') ||
			('0' <= b && b <= '9') ||
			b == ' ' ||
			b == '.' ||
			b == '-' {
			result.WriteByte(b)
		}
	}
	return result.String()
}

func writeFile(outPath string, data []byte) error {
	fileDir := filepath.Dir(outPath)
	if err := os.MkdirAll(fileDir, os.ModePerm); err != nil {
		return fmt.Errorf("create dir (%s) failed, err: %s", fileDir, err)
	}
	if err := ioutil.WriteFile(outPath, data, 0644); err != nil {
		return fmt.Errorf("write to file failed, err: %s", err)
	}
	return nil
}
